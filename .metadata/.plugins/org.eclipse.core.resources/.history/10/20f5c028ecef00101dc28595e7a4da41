#include "protocol.h"
#include <string.h>

#define RX_BUF_SIZE 512

typedef struct {
    uint8_t receiving;
    uint16_t idx;
    uint8_t buf[RX_BUF_SIZE]; // tu trzymamy "środek" ramki (między START a END)
} rx_state_t;

static rx_state_t s_rx;

static uint16_t crc16_ccitt_false(const uint8_t *data, uint16_t len)
{
    uint16_t crc = 0xFFFF;
    for (uint16_t i = 0; i < len; i++) {
        crc ^= (uint16_t)data[i] << 8;
        for (uint8_t b = 0; b < 8; b++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
            else crc <<= 1;
        }
    }
    return crc;
}

static uint16_t escape_bytes(const uint8_t *in, uint16_t len, uint8_t *out)
{
    uint16_t j = 0;
    for (uint16_t i = 0; i < len; i++) {
        uint8_t v = in[i];
        if (v == FRAME_START || v == FRAME_END || v == FRAME_ESC) {
            out[j++] = FRAME_ESC;
            out[j++] = (uint8_t)(v ^ FRAME_XOR);
        } else {
            out[j++] = v;
        }
    }
    return j;
}

static uint16_t unescape_bytes(const uint8_t *in, uint16_t len, uint8_t *out)
{
    uint16_t j = 0;
    for (uint16_t i = 0; i < len; i++) {
        if (in[i] == FRAME_ESC) {
            if (i + 1 >= len) return 0; // błąd formatu
            out[j++] = (uint8_t)(in[++i] ^ FRAME_XOR);
        } else {
            out[j++] = in[i];
        }
    }
    return j;
}

static void handle_command(proto_ctx_t *ctx, uint8_t src, uint8_t cmd, const uint8_t *payload, uint8_t len);

void proto_init(proto_ctx_t *ctx, UART_HandleTypeDef *huart, uint8_t self_addr)
{
    ctx->huart = huart;
    ctx->self_addr = self_addr;
    memset(&s_rx, 0, sizeof(s_rx));
}

void proto_send_frame(proto_ctx_t *ctx, uint8_t dst, uint8_t cmd, const uint8_t *data, uint8_t len)
{
    // RAW = SRC DST CMD LEN DATA CRC16(LSB,MSB)
    uint8_t raw[300];
    uint16_t r = 0;

    raw[r++] = ctx->self_addr;
    raw[r++] = dst;
    raw[r++] = cmd;
    raw[r++] = len;

    for (uint8_t i = 0; i < len; i++) raw[r++] = data[i];

    uint16_t crc = crc16_ccitt_false(raw, r);
    raw[r++] = (uint8_t)(crc & 0xFF);
    raw[r++] = (uint8_t)((crc >> 8) & 0xFF);

    uint8_t esc[420];
    uint16_t e = escape_bytes(raw, r, esc);

    uint8_t frame[450];
    uint16_t f = 0;
    frame[f++] = FRAME_START;
    memcpy(&frame[f], esc, e); f += e;
    frame[f++] = FRAME_END;

    HAL_UART_Transmit(ctx->huart, frame, f, HAL_MAX_DELAY);
}

void proto_send_ack(proto_ctx_t *ctx, uint8_t dst)
{
    proto_send_frame(ctx, dst, CMD_ACK, NULL, 0);
}

void proto_send_nack(proto_ctx_t *ctx, uint8_t dst, uint8_t err)
{
    proto_send_frame(ctx, dst, CMD_NACK, &err, 1);
}

static void process_frame(proto_ctx_t *ctx, const uint8_t *mid, uint16_t mid_len)
{
    uint8_t dec[300];
    uint16_t dec_len = unescape_bytes(mid, mid_len, dec);
    if (dec_len < 6) { // minimum
        proto_send_nack(ctx, ADDR_PC, ERR_FORMAT_ERROR);
        return;
    }

    uint8_t src = dec[0];
    uint8_t dst = dec[1];
    uint8_t cmd = dec[2];
    uint8_t len = dec[3];

    // dst musi być do nas
    if (dst != ctx->self_addr) return;

    // sprawdź spójność długości: SRC DST CMD LEN + DATA(len) + CRC(2)
    if ((uint16_t)len + 6 != dec_len) {
        proto_send_nack(ctx, src, ERR_FORMAT_ERROR);
        return;
    }

    uint16_t recv_crc = (uint16_t)dec[dec_len - 2] | ((uint16_t)dec[dec_len - 1] << 8);
    uint16_t calc_crc = crc16_ccitt_false(dec, (uint16_t)(dec_len - 2));
    if (recv_crc != calc_crc) {
        proto_send_nack(ctx, src, ERR_CRC_ERROR);
        return;
    }

    const uint8_t *payload = &dec[4];
    handle_command(ctx, src, cmd, payload, len);
}

void proto_rx_byte(proto_ctx_t *ctx, uint8_t b)
{
    if (b == FRAME_START) {
        s_rx.receiving = 1;
        s_rx.idx = 0;
        return;
    }

    if (!s_rx.receiving) return;

    if (b == FRAME_END) {
        s_rx.receiving = 0;
        process_frame(ctx, s_rx.buf, s_rx.idx);
        return;
    }

    if (s_rx.idx < RX_BUF_SIZE) {
        s_rx.buf[s_rx.idx++] = b;
    } else {
        s_rx.receiving = 0;
        proto_send_nack(ctx, ADDR_PC, ERR_FORMAT_ERROR);
    }
}

static void handle_command(proto_ctx_t *ctx, uint8_t src, uint8_t cmd, const uint8_t *payload, uint8_t len)
{
    switch (cmd)
    {
        case CMD_READ_NOW:
        {
            // natychmiastowy pomiar -> CUR_VALUE (LEN=2, int16 little-endian)
            int16_t t = app_read_bme280_temp_centi();
            uint8_t out[2] = { (uint8_t)(t & 0xFF), (uint8_t)((t >> 8) & 0xFF) };
            proto_send_frame(ctx, src, CMD_CUR_VALUE, out, 2);
            break;
        }

        case CMD_SET_PERIOD:
        {
            if (len != 4) { proto_send_nack(ctx, src, ERR_PARAM_ERROR); break; }
            uint32_t p =  (uint32_t)payload[0]
                        | ((uint32_t)payload[1] << 8)
                        | ((uint32_t)payload[2] << 16)
                        | ((uint32_t)payload[3] << 24);

            // ograniczenia z projektu: nie częściej niż raz/min i max 30 min
            if (p < 60000u || p > 1800000u) { proto_send_nack(ctx, src, ERR_PARAM_ERROR); break; }

            app_set_period_ms(p);
            proto_send_ack(ctx, src);
            break;
        }

        case CMD_GET_PERIOD:
        {
            uint32_t p = app_get_period_ms();
            uint8_t out[4] = {
                (uint8_t)(p & 0xFF),
                (uint8_t)((p >> 8) & 0xFF),
                (uint8_t)((p >> 16) & 0xFF),
                (uint8_t)((p >> 24) & 0xFF),
            };
            proto_send_frame(ctx, src, CMD_GET_PERIOD, out, 4);
            break;
        }

        case CMD_GET_HISTORY:
        {
            // payload[0] = N (ile pomiarów chcesz)
            if (len != 1) { proto_send_nack(ctx, src, ERR_PARAM_ERROR); break; }
            uint8_t N = payload[0];
            if (N == 0 || N > 200) { proto_send_nack(ctx, src, ERR_PARAM_ERROR); break; }

            int16_t temps[200];
            uint8_t got = app_get_history(N, temps);
            if (got == 0) { proto_send_nack(ctx, src, ERR_NO_DATA); break; }

            // HISTORY_DATA: lista int16 little-endian => LEN = got*2
            uint8_t out[400];
            for (uint8_t i = 0; i < got; i++) {
                out[i*2 + 0] = (uint8_t)(temps[i] & 0xFF);
                out[i*2 + 1] = (uint8_t)((temps[i] >> 8) & 0xFF);
            }
            proto_send_frame(ctx, src, CMD_HISTORY_DATA, out, (uint8_t)(got * 2));
            break;
        }

        default:
            proto_send_nack(ctx, src, ERR_FORMAT_ERROR);
            break;
    }
}
